name: Create Release

on:
  pull_request:
    types:
      - closed
    branches:
      - main
  workflow_dispatch:

# Ignore Dependabot actions
jobs:
  check-release-branch:
    name: Check Release Branch
    runs-on: ubuntu-latest
    outputs:
      is-dependabot: ${{ steps.check-dependabot.outputs.is-dependabot }}
      is-release-branch: ${{ steps.check-branch.outputs.is-release-branch }}
      version: ${{ steps.extract-version.outputs.version }}
    steps:
      - name: Check if triggered by Dependabot
        id: check-dependabot
        run: |
          ACTOR="${{ github.actor }}"
          # Bei workflow_dispatch gibt es keinen Pull Request
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "$ACTOR" = "dependabot[bot]" ]; then
              echo "is-dependabot=true" >> $GITHUB_OUTPUT
              echo "Skipping release creation - triggered by Dependabot"
            else
              echo "is-dependabot=false" >> $GITHUB_OUTPUT
              echo "Not triggered by Dependabot, checking branch..."
            fi
          else
            PR_AUTHOR="${{ github.event.pull_request.user.login }}"
            if [ "$ACTOR" = "dependabot[bot]" ] || [ "$PR_AUTHOR" = "dependabot[bot]" ]; then
              echo "is-dependabot=true" >> $GITHUB_OUTPUT
              echo "Skipping release creation - triggered by Dependabot"
            else
              echo "is-dependabot=false" >> $GITHUB_OUTPUT
              echo "Not triggered by Dependabot, checking branch..."
            fi
          fi

      - name: Check if release branch
        id: check-branch
        run: |
          # Bei workflow_dispatch: github.head_ref oder github.ref verwenden
          # Bei pull_request: github.event.pull_request.head.ref verwenden
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          else
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          fi

          if [[ "$BRANCH_NAME" =~ ^releases/v ]]; then
            echo "is-release-branch=true" >> $GITHUB_OUTPUT
            echo "Release branch detected: $BRANCH_NAME"
          else
            echo "is-release-branch=false" >> $GITHUB_OUTPUT
            echo "Not a release branch: $BRANCH_NAME"
          fi

      - name: Extract version from branch name
        id: extract-version
        if: steps.check-branch.outputs.is-release-branch == 'true'
        run: |
          # Bei workflow_dispatch: github.head_ref oder github.ref_name verwenden
          # Bei pull_request: github.event.pull_request.head.ref verwenden
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          else
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          fi
          # Extract version from releases/v0.2.4 -> 0.2.4
          VERSION=$(echo "$BRANCH_NAME" | sed 's/^releases\/v//')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Extracted version: ${VERSION}"

  create-release:
    name: Create Release
    needs: check-release-branch
    if: |
      needs.check-release-branch.outputs.is-dependabot == 'false' &&
      needs.check-release-branch.outputs.is-release-branch == 'true' &&
      (github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true)
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && github.ref || github.event.pull_request.merge_commit_sha }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          cache: 'npm'

      - name: Verify version from package.json
        id: verify-version
        run: |
          PACKAGE_VERSION=$(npm pkg get version | tr -d '"')
          BRANCH_VERSION="${{ needs.check-release-branch.outputs.version }}"

          if [ "$PACKAGE_VERSION" != "$BRANCH_VERSION" ]; then
            echo "‚ùå Version mismatch!"
            echo "Package.json version: $PACKAGE_VERSION"
            echo "Branch version: $BRANCH_VERSION"
            exit 1
          fi

          echo "version=${PACKAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "‚úÖ Version verified: ${PACKAGE_VERSION}"

      - name: Check if release already exists
        id: check-release
        run: |
          VERSION="${{ needs.check-release-branch.outputs.version }}"
          if gh release view "v${VERSION}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Release v${VERSION} already exists, skipping..."
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Release v${VERSION} does not exist, will create..."
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ============================================================================
      # Phase 1: User Story 1 - Release-Vergleich zum Vorg√§nger
      # ============================================================================
      # Find the most recently created release (by creation date, not semantic version)
      # Handles edge cases: first release, tag not found (404), API rate limits
      - name: Find previous release
        id: previous-release
        if: steps.check-release.outputs.exists == 'false'
        run: |
          set +e
          # Query GitHub Releases API, sort by created_at, get most recent
          # Error handling: continue-on-error ensures workflow continues even if API fails
          PREVIOUS_RELEASE=$(gh api repos/${{ github.repository }}/releases \
            --jq 'sort_by(.created_at) | reverse | .[0].tag_name // empty' 2>/dev/null)

          if [ -z "$PREVIOUS_RELEASE" ] || [ "$PREVIOUS_RELEASE" = "null" ]; then
            echo "previous_exists=false" >> $GITHUB_OUTPUT
            echo "No previous release found (first release or tag not found)"
          else
            CURRENT_TAG="v${{ needs.check-release-branch.outputs.version }}"
            if [ "$PREVIOUS_RELEASE" = "$CURRENT_TAG" ]; then
              # If the only release is the current one, check for second most recent
              PREVIOUS_RELEASE=$(gh api repos/${{ github.repository }}/releases \
                --jq 'sort_by(.created_at) | reverse | .[1].tag_name // empty' 2>/dev/null)
              if [ -z "$PREVIOUS_RELEASE" ] || [ "$PREVIOUS_RELEASE" = "null" ]; then
                echo "previous_exists=false" >> $GITHUB_OUTPUT
                echo "No previous release found (first release)"
              else
                echo "previous_exists=true" >> $GITHUB_OUTPUT
                echo "previous_tag=${PREVIOUS_RELEASE}" >> $GITHUB_OUTPUT
                echo "Previous release: ${PREVIOUS_RELEASE}"
              fi
            else
              echo "previous_exists=true" >> $GITHUB_OUTPUT
              echo "previous_tag=${PREVIOUS_RELEASE}" >> $GITHUB_OUTPUT
              echo "Previous release: ${PREVIOUS_RELEASE}"
            fi
          fi
          set -e
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Create comparison link
        id: comparison-link
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.previous-release.outputs.previous_exists == 'true'
        run: |
          CURRENT_TAG="v${{ needs.check-release-branch.outputs.version }}"
          PREVIOUS_TAG="${{ steps.previous-release.outputs.previous_tag }}"
          COMPARISON_URL="https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG}"

          echo "comparison_url=${COMPARISON_URL}" >> $GITHUB_OUTPUT
          echo "Comparison URL: ${COMPARISON_URL}"

      - name: Format comparison link section
        id: format-comparison
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.previous-release.outputs.previous_exists == 'true'
        run: |
          CURRENT_TAG="v${{ needs.check-release-branch.outputs.version }}"
          PREVIOUS_TAG="${{ steps.previous-release.outputs.previous_tag }}"
          COMPARISON_URL="${{ steps.comparison-link.outputs.comparison_url }}"

          cat <<EOF >> $GITHUB_OUTPUT
          comparison_section<<COMPARISON_EOF
          ### üîÑ Vergleich zum Vorg√§nger-Release
          - [Vergleich ${PREVIOUS_TAG}...${CURRENT_TAG}](${COMPARISON_URL})

          COMPARISON_EOF
          EOF

      # ============================================================================
      # Phase 2: User Story 2 - Automatische PR-Liste aus Diff
      # ============================================================================
      # Get commits between previous and current release using GitHub Compare API
      # Error handling: continue-on-error ensures workflow continues even if API fails
      - name: Get commits between releases
        id: get-commits
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.previous-release.outputs.previous_exists == 'true'
        run: |
          set +e
          CURRENT_TAG="v${{ needs.check-release-branch.outputs.version }}"
          PREVIOUS_TAG="${{ steps.previous-release.outputs.previous_tag }}"

          # Use GitHub Compare API: GET /repos/{owner}/{repo}/compare/{base}...{head}
          gh api repos/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG} \
            --jq '.commits[] | {sha: .sha, message: .commit.message}' > commits.json 2>/dev/null

          if [ -s commits.json ]; then
            echo "commits_file=commits.json" >> $GITHUB_OUTPUT
            echo "‚úÖ Found commits between ${PREVIOUS_TAG} and ${CURRENT_TAG}"
          else
            echo "commits_file=" >> $GITHUB_OUTPUT
            echo "No commits found between ${PREVIOUS_TAG} and ${CURRENT_TAG}"
          fi
          set -e
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Extract PR numbers
        id: extract-prs
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.get-commits.outputs.commits_file != ''
        run: |
          set +e
          # Extract PR numbers from commit messages using regex patterns
          # Patterns: #123, pull request #123, Merge pull request #123, etc.
          PR_NUMBERS=$(jq -r '.message | match("#(\\d+)") | .captures[0].string // empty' commits.json 2>/dev/null | grep -v '^$' | sort -u | tr '\n' ' ')

          if [ -n "$PR_NUMBERS" ]; then
            echo "pr_numbers=${PR_NUMBERS}" >> $GITHUB_OUTPUT
            echo "‚úÖ Extracted PR numbers: ${PR_NUMBERS}"
          else
            echo "pr_numbers=" >> $GITHUB_OUTPUT
            echo "No PR numbers found in commit messages"
          fi
          set -e
        continue-on-error: true

      - name: Get PR details
        id: get-pr-details
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.extract-prs.outputs.pr_numbers != ''
        run: |
          set +e
          PR_DETAILS="[]"

          for PR_NUM in ${{ steps.extract-prs.outputs.pr_numbers }}; do
            PR_DATA=$(gh api repos/${{ github.repository }}/pulls/${PR_NUM} \
              --jq '{number: .number, title: .title, url: .html_url, author: .user.login, merged_at: .merged_at, state: .state, merged: .merged}' 2>/dev/null || echo 'null')
            
            if [ "$PR_DATA" != "null" ] && [ -n "$PR_DATA" ]; then
              PR_DETAILS=$(echo "$PR_DETAILS" | jq ". + [$PR_DATA]")
            fi
          done

          if [ "$PR_DETAILS" != "[]" ] && [ -n "$PR_DETAILS" ]; then
            echo "$PR_DETAILS" > prs.json
            echo "prs_file=prs.json" >> $GITHUB_OUTPUT
            echo "‚úÖ Fetched PR details"
          else
            echo "prs_file=" >> $GITHUB_OUTPUT
            echo "No PR details found"
          fi
          set -e
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Filter merged PRs
        id: filter-merged-prs
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.get-pr-details.outputs.prs_file != ''
        run: |
          set +e
          # Filter only merged PRs (state is "closed" and merged is true)
          MERGED_PRS=$(jq '[.[] | select(.state == "closed" and .merged == true)]' prs.json 2>/dev/null)

          if [ "$MERGED_PRS" != "[]" ] && [ -n "$MERGED_PRS" ]; then
            echo "$MERGED_PRS" > merged_prs.json
            echo "merged_prs_file=merged_prs.json" >> $GITHUB_OUTPUT
            echo "‚úÖ Filtered merged PRs"
          else
            echo "merged_prs_file=" >> $GITHUB_OUTPUT
            echo "No merged PRs found"
          fi
          set -e
        continue-on-error: true

      - name: Format PR list section
        id: format-pr-list
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.filter-merged-prs.outputs.merged_prs_file != ''
        run: |
          set +e
          PR_COUNT=$(jq 'length' merged_prs.json 2>/dev/null || echo "0")

          if [ "$PR_COUNT" -gt 0 ]; then
            cat <<EOF >> $GITHUB_OUTPUT
          pr_list_section<<PR_LIST_EOF
          ### üìã Pull Requests
          $(jq -r '.[] | "- [\(.title) (#\(.number))](\(.url)) - @\(.author)"' merged_prs.json)

          PR_LIST_EOF
          EOF
            echo "‚úÖ Formatted PR list section with ${PR_COUNT} PRs"
          else
            echo "pr_list_section=" >> $GITHUB_OUTPUT
            echo "No PRs to format"
          fi
          set -e
        continue-on-error: true

      # ============================================================================
      # Phase 3: User Story 3 - Contributors-Liste
      # ============================================================================
      # Collect contributors from three sources: PR authors, commit authors, PR reviewers
      # Filter out bots (dependabot, github-actions, cursor, etc.) and deduplicate
      - name: Collect PR authors
        id: collect-pr-authors
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.filter-merged-prs.outputs.merged_prs_file != ''
        run: |
          set +e
          # Extract PR authors from merged PRs (user.login from each PR)
          PR_AUTHORS=$(jq -r '.[].author' merged_prs.json 2>/dev/null | sort -u | tr '\n' ' ')

          if [ -n "$PR_AUTHORS" ]; then
            echo "pr_authors=${PR_AUTHORS}" >> $GITHUB_OUTPUT
            echo "‚úÖ Collected PR authors: ${PR_AUTHORS}"
          else
            echo "pr_authors=" >> $GITHUB_OUTPUT
            echo "No PR authors found"
          fi
          set -e
        continue-on-error: true

      - name: Collect commit authors
        id: collect-commit-authors
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.get-commits.outputs.commits_file != ''
        run: |
          set +e
          # Extract commit authors from commits
          COMMIT_AUTHORS=""

          for SHA in $(jq -r '.[].sha' commits.json 2>/dev/null | head -20); do
            AUTHOR=$(gh api repos/${{ github.repository }}/commits/${SHA} \
              --jq '.author.login // empty' 2>/dev/null || echo '')
            if [ -n "$AUTHOR" ]; then
              COMMIT_AUTHORS="${COMMIT_AUTHORS} ${AUTHOR}"
            fi
          done

          COMMIT_AUTHORS=$(echo "$COMMIT_AUTHORS" | tr ' ' '\n' | sort -u | tr '\n' ' ')

          if [ -n "$COMMIT_AUTHORS" ]; then
            echo "commit_authors=${COMMIT_AUTHORS}" >> $GITHUB_OUTPUT
            echo "‚úÖ Collected commit authors: ${COMMIT_AUTHORS}"
          else
            echo "commit_authors=" >> $GITHUB_OUTPUT
            echo "No commit authors found"
          fi
          set -e
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Collect PR reviewers
        id: collect-pr-reviewers
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.filter-merged-prs.outputs.merged_prs_file != ''
        run: |
          set +e
          # Extract PR reviewers from merged PRs (only approved reviews)
          PR_REVIEWERS=""

          for PR_NUM in $(jq -r '.[].number' merged_prs.json 2>/dev/null); do
            REVIEWERS=$(gh api repos/${{ github.repository }}/pulls/${PR_NUM}/reviews \
              --jq '.[] | select(.state == "APPROVED") | .user.login' 2>/dev/null || echo '')
            if [ -n "$REVIEWERS" ]; then
              PR_REVIEWERS="${PR_REVIEWERS} ${REVIEWERS}"
            fi
          done

          PR_REVIEWERS=$(echo "$PR_REVIEWERS" | tr ' ' '\n' | sort -u | tr '\n' ' ')

          if [ -n "$PR_REVIEWERS" ]; then
            echo "pr_reviewers=${PR_REVIEWERS}" >> $GITHUB_OUTPUT
            echo "‚úÖ Collected PR reviewers: ${PR_REVIEWERS}"
          else
            echo "pr_reviewers=" >> $GITHUB_OUTPUT
            echo "No PR reviewers found"
          fi
          set -e
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Filter out bots
        id: filter-bots
        if: |
          steps.check-release.outputs.exists == 'false' &&
          (steps.collect-pr-authors.outputs.pr_authors != '' ||
           steps.collect-commit-authors.outputs.commit_authors != '' ||
           steps.collect-pr-reviewers.outputs.pr_reviewers != '')
        run: |
          set +e
          # Combine all contributors
          ALL_CONTRIBUTORS="${{ steps.collect-pr-authors.outputs.pr_authors }} ${{ steps.collect-commit-authors.outputs.commit_authors }} ${{ steps.collect-pr-reviewers.outputs.pr_reviewers }}"

          # Filter out bots (dependabot, github-actions, cursor, etc.)
          BOT_PATTERNS="dependabot github-actions cursor"
          FILTERED_CONTRIBUTORS=""

          for CONTRIBUTOR in $(echo "$ALL_CONTRIBUTORS" | tr ' ' '\n' | sort -u); do
            if [ -z "$CONTRIBUTOR" ]; then
              continue
            fi
            
            IS_BOT=false
            # Check if username ends with [bot]
            if [[ "$CONTRIBUTOR" == *"[bot]" ]]; then
              IS_BOT=true
            fi
            
            # Check if username matches known bot patterns
            for BOT in $BOT_PATTERNS; do
              if [[ "$CONTRIBUTOR" == *"$BOT"* ]]; then
                IS_BOT=true
                break
              fi
            done
            
            if [ "$IS_BOT" = "false" ]; then
              FILTERED_CONTRIBUTORS="${FILTERED_CONTRIBUTORS} ${CONTRIBUTOR}"
            fi
          done

          FILTERED_CONTRIBUTORS=$(echo "$FILTERED_CONTRIBUTORS" | tr ' ' '\n' | sort -u | tr '\n' ' ')

          if [ -n "$FILTERED_CONTRIBUTORS" ]; then
            echo "contributors=${FILTERED_CONTRIBUTORS}" >> $GITHUB_OUTPUT
            echo "‚úÖ Filtered contributors (bots excluded): ${FILTERED_CONTRIBUTORS}"
          else
            echo "contributors=" >> $GITHUB_OUTPUT
            echo "No contributors found (after filtering bots)"
          fi
          set -e
        continue-on-error: true

      - name: Format contributors section
        id: format-contributors
        if: |
          steps.check-release.outputs.exists == 'false' &&
          steps.filter-bots.outputs.contributors != ''
        run: |
          set +e
          CONTRIBUTOR_COUNT=$(echo "${{ steps.filter-bots.outputs.contributors }}" | tr ' ' '\n' | grep -v '^$' | wc -l | tr -d ' ')

          if [ "$CONTRIBUTOR_COUNT" -gt 0 ]; then
            cat <<EOF >> $GITHUB_OUTPUT
          contributors_section<<CONTRIBUTORS_EOF
          ### üë• Contributors
          $(for CONTRIBUTOR in ${{ steps.filter-bots.outputs.contributors }}; do
              echo "- [@${CONTRIBUTOR}](https://github.com/${CONTRIBUTOR})"
            done)

          CONTRIBUTORS_EOF
          EOF
            echo "‚úÖ Formatted contributors section with ${CONTRIBUTOR_COUNT} contributors"
          else
            echo "contributors_section=" >> $GITHUB_OUTPUT
            echo "No contributors to format"
          fi
          set -e
        continue-on-error: true

      - name: Install dependencies
        if: steps.check-release.outputs.exists == 'false'
        run: npm ci

      - name: Build application
        id: build
        if: steps.check-release.outputs.exists == 'false'
        run: npm run build

      - name: Create ZIP archive
        id: create-zip
        if: steps.check-release.outputs.exists == 'false'
        run: |
          VERSION="${{ needs.check-release-branch.outputs.version }}"
          ZIP_NAME="timemanager-v${VERSION}.zip"

          # Erstelle ZIP-Datei aus dem dist/ Ordner
          cd dist
          zip -r "../${ZIP_NAME}" .
          cd ..

          # Setze den Pfad als Output
          echo "zip_path=${ZIP_NAME}" >> $GITHUB_OUTPUT
          echo "zip_name=${ZIP_NAME}" >> $GITHUB_OUTPUT
          echo "‚úÖ Created ZIP archive: ${ZIP_NAME}"

      - name: Prepare release body
        id: prepare-body
        if: steps.check-release.outputs.exists == 'false'
        run: |
          VERSION="${{ needs.check-release-branch.outputs.version }}"
          EVENT_NAME="${{ github.event_name }}"

          ZIP_NAME="timemanager-v${VERSION}.zip"

          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            BRANCH="${{ github.head_ref || github.ref_name }}"
            RELEASE_BODY="## Version ${VERSION}

          Manuell erstelltes Release vom Release-Branch.

          ### üì¶ Build-Artefakte
          - **ZIP-Archiv**: \`${ZIP_NAME}\` (enth√§lt den kompletten Inhalt des \`dist/\` Ordners)
          - Branch: \`${BRANCH}\`

          ### üîó Links
          - [Workflow Run #${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [Commit: ${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
          - **Erstellt von**: ${{ github.actor }}

          ### üìù √Ñnderungen
          Siehe [Changelog](/CHANGELOG.md) f√ºr detaillierte √Ñnderungen."
          else
            BRANCH="${{ github.event.pull_request.head.ref }}"
            RELEASE_BODY="## Version ${VERSION}

          Automatisch erstelltes Release nach Merge des Release-Branches.

          ### üì¶ Build-Artefakte
          - **ZIP-Archiv**: \`${ZIP_NAME}\` (enth√§lt den kompletten Inhalt des \`dist/\` Ordners)
          - Gemerged aus Branch: \`${BRANCH}\`

          ### üîó Links
          - [Pull Request #${{ github.event.pull_request.number }}](${{ github.event.pull_request.html_url }})
          - [Merge Commit: ${{ github.event.pull_request.merge_commit_sha }}](https://github.com/${{ github.repository }}/commit/${{ github.event.pull_request.merge_commit_sha }})
          - **Merged by**: ${{ github.event.pull_request.merged_by.login }}

          ### üìù √Ñnderungen
          Siehe [Changelog](/CHANGELOG.md) f√ºr detaillierte √Ñnderungen.

          ### üìã Pull Request Details
          **Titel**: ${{ github.event.pull_request.title }}
          **Beschreibung**: ${{ github.event.pull_request.body }}"
          fi

          # ============================================================================
          # Insert new sections into release body
          # Section order: Build-Artefakte -> Comparison -> PR List -> Contributors -> Links
          # ============================================================================
          # Insert comparison section after "Build-Artefakte" and before "Links"
          # Error handling: If comparison section is empty (no previous release), skip insertion
          if [ -n "${{ steps.format-comparison.outputs.comparison_section }}" ]; then
            COMPARISON_SECTION="${{ steps.format-comparison.outputs.comparison_section }}"
            # Use a temporary file to handle multiline insertion
            echo "$RELEASE_BODY" > /tmp/release_body.txt
            # Insert comparison section before "Links" section
            sed -i "/^### üîó Links/i\\${COMPARISON_SECTION}" /tmp/release_body.txt
            RELEASE_BODY=$(cat /tmp/release_body.txt)
          fi

          # Insert PR list section after comparison section (or after "Build-Artefakte" if no comparison)
          # Error handling: If PR list section is empty (no PRs in diff), skip insertion
          if [ -n "${{ steps.format-pr-list.outputs.pr_list_section }}" ]; then
            PR_LIST_SECTION="${{ steps.format-pr-list.outputs.pr_list_section }}"
            # Use a temporary file to handle multiline insertion
            echo "$RELEASE_BODY" > /tmp/release_body.txt
            # Insert PR list section before "Links" section (after comparison if exists)
            if [ -n "${{ steps.format-comparison.outputs.comparison_section }}" ]; then
              # Insert after comparison section
              sed -i "/^### üîó Links/i\\${PR_LIST_SECTION}" /tmp/release_body.txt
            else
              # Insert after "Build-Artefakte" section
              sed -i "/^### üîó Links/i\\${PR_LIST_SECTION}" /tmp/release_body.txt
            fi
            RELEASE_BODY=$(cat /tmp/release_body.txt)
          fi

          # Insert contributors section after PR list section (or after comparison/PR list if exists)
          # Error handling: If contributors section is empty (no contributors identified), skip insertion
          if [ -n "${{ steps.format-contributors.outputs.contributors_section }}" ]; then
            CONTRIBUTORS_SECTION="${{ steps.format-contributors.outputs.contributors_section }}"
            # Use a temporary file to handle multiline insertion
            echo "$RELEASE_BODY" > /tmp/release_body.txt
            # Insert contributors section before "Links" section (after PR list if exists)
            sed -i "/^### üîó Links/i\\${CONTRIBUTORS_SECTION}" /tmp/release_body.txt
            RELEASE_BODY=$(cat /tmp/release_body.txt)
          fi

          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create release
        id: create-release
        if: steps.check-release.outputs.exists == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.check-release-branch.outputs.version }}
          name: Release v${{ needs.check-release-branch.outputs.version }}
          body: ${{ steps.prepare-body.outputs.body }}
          files: |
            ${{ steps.create-zip.outputs.zip_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Capture error details
        if: failure() && steps.check-release.outputs.exists == 'false'
        id: error-details
        run: |
          # Sammle Fehlerdetails aus den vorherigen Steps
          ERROR_STEPS=""
          if [ "${{ steps.verify-version.outcome }}" = "failure" ]; then
            ERROR_STEPS="${ERROR_STEPS}‚Ä¢ Versions-Validierung fehlgeschlagen\n"
          fi
          if [ "${{ steps.check-release.outcome }}" = "failure" ]; then
            ERROR_STEPS="${ERROR_STEPS}‚Ä¢ Release-Check fehlgeschlagen\n"
          fi
          if [ "${{ steps.build.outcome }}" = "failure" ]; then
            ERROR_STEPS="${ERROR_STEPS}‚Ä¢ Build fehlgeschlagen\n"
          fi
          if [ "${{ steps.create-zip.outcome }}" = "failure" ]; then
            ERROR_STEPS="${ERROR_STEPS}‚Ä¢ ZIP-Archiv-Erstellung fehlgeschlagen\n"
          fi
          if [ "${{ steps.create-release.outcome }}" = "failure" ]; then
            ERROR_STEPS="${ERROR_STEPS}‚Ä¢ Release-Erstellung fehlgeschlagen\n"
          fi

          ERROR_MSG=$(cat <<EOF
          **Fehlerhafte Schritte:**
          ${ERROR_STEPS:-"‚Ä¢ Unbekannter Fehler"}

          **Technische Details:**
          - Workflow: ${{ github.workflow }}
          - Job: ${{ github.job }}
          - Run ID: ${{ github.run_id }}
          EOF
          )
          echo "error_details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$ERROR_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Release created successfully
        if: success() && steps.check-release.outputs.exists == 'false'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TG_CHANNEL }}
          token: ${{ secrets.TG_BOT }}
          format: markdown
          message: |
            ‚úÖ *Release v${{ needs.check-release-branch.outputs.version }} erfolgreich erstellt*

            Das Release v${{ needs.check-release-branch.outputs.version }} wurde **erfolgreich** erstellt!

            üì¶ **Version**: ${{ needs.check-release-branch.outputs.version }}
            üîÄ **Branch**: `${{ github.event_name == 'workflow_dispatch' && (github.head_ref || github.ref_name) || github.event.pull_request.head.ref }}`
            üìÖ **Datum**: ${{ github.event_name == 'workflow_dispatch' && github.event.head_commit.timestamp || github.event.pull_request.merged_at }}
            üë§ **${{ github.event_name == 'workflow_dispatch' && 'Erstellt von' || 'Merged by' }}**: [${{ github.event_name == 'workflow_dispatch' && github.actor || github.event.pull_request.merged_by.login }}](https://github.com/${{ github.event_name == 'workflow_dispatch' && github.actor || github.event.pull_request.merged_by.login }})

            ${{ github.event_name != 'workflow_dispatch' && format('**Pull Request**: [#{0}]({1})', github.event.pull_request.number, github.event.pull_request.html_url) || format('**Workflow Run**: [{0}]({1})', github.run_id, format('{0}/{1}/actions/runs/{2}', github.server_url, github.repository, github.run_id)) }}

            üîó [Release ansehen](https://github.com/${{ github.repository }}/releases/tag/v${{ needs.check-release-branch.outputs.version }})
            üîç [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
        continue-on-error: true

      - name: Release creation failed
        if: failure() && steps.check-release.outputs.exists == 'false'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TG_CHANNEL }}
          token: ${{ secrets.TG_BOT }}
          format: markdown
          message: |
            ‚ùå *Release-Erstellung fehlgeschlagen - v${{ needs.check-release-branch.outputs.version }}*

            Die Release-Erstellung f√ºr v${{ needs.check-release-branch.outputs.version }} ist **fehlgeschlagen**!

            üì¶ **Version**: ${{ needs.check-release-branch.outputs.version }}
            üîÄ **Branch**: `${{ github.event_name == 'workflow_dispatch' && (github.head_ref || github.ref_name) || github.event.pull_request.head.ref }}`
            üìÖ **Datum**: ${{ github.event_name == 'workflow_dispatch' && github.event.head_commit.timestamp || github.event.pull_request.merged_at }}
            üë§ **${{ github.event_name == 'workflow_dispatch' && 'Erstellt von' || 'Merged by' }}**: [${{ github.event_name == 'workflow_dispatch' && github.actor || github.event.pull_request.merged_by.login }}](https://github.com/${{ github.event_name == 'workflow_dispatch' && github.actor || github.event.pull_request.merged_by.login }})

            ${{ github.event_name != 'workflow_dispatch' && format('**Pull Request**: [#{0}]({1})', github.event.pull_request.number, github.event.pull_request.html_url) || format('**Workflow Run**: [{0}]({1})', github.run_id, format('{0}/{1}/actions/runs/{2}', github.server_url, github.repository, github.run_id)) }}

            ### ‚ùå Fehlerdetails:
            ${{ steps.error-details.outputs.error_details }}

            ### üîç Weitere Informationen:
            Bitte √ºberpr√ºfe die GitHub Actions Logs f√ºr detaillierte Fehlerinformationen.

            üîç [Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
        continue-on-error: true

      - name: Release created
        if: success() && steps.check-release.outputs.exists == 'false'
        run: |
          VERSION="${{ needs.check-release-branch.outputs.version }}"
          echo "‚úÖ Release v${VERSION} successfully created!"
          echo "üîó https://github.com/${{ github.repository }}/releases/tag/v${VERSION}"
